## The complete and the restricted log-likelihoods
restricted_log_likelihood <- function(pars, x, z, p, i, t) {
    mu <- pars[1]
    theta <- pars[2]

    log_likelihood <- restricted_loglikelihood(x = x, z = z, mu = mu, theta = theta, p = p, i = i, t = t)
    return(-log_likelihood)
}

#' Control function for the \link{em_itnb} function.
#'
#' @description Creates a list of default options.
#'
#' @param trace Numeric (>= 0): showing a trace every \code{trace} number of iterations.
#' @param tolerance Numeric: Convergence tolerance.
#' @param iteration_min Numeric (>= 0): The minimum number of allowed iterations.
#' @param iteration_max Numeric (>= \code{iteration_min}): The maximum number of allowed iterations.
#' @param save_trace TRUE/FALSE: should the entire trace be stored?
#'
#' @return A list of default arguments for the \link{em_itnb} function.
#' @export
em_itnb_control <- function(trace = 0, tolerance = 1e-6, iteration_min = 5, iteration_max = 10000, save_trace = FALSE) {
    if (!is.numeric(trace)) {
        stop("'trace' has to be numeric.")
    }
    trace <- ceiling(trace)

    if (!is.numeric(tolerance)) {
        stop("'tolerance' has to be numeric.")
    }

    if (tolerance <= .Machine$double.eps) {
        stop("'tolerance' has to be bigger than two times the machine epsilon.")
    }

    if (!is.numeric(iteration_min)) {
        stop("'iteration_min' has to be numeric.")
    }
    iteration_min <- ceiling(iteration_min)

    if (!is.numeric(iteration_max)) {
        stop("'iteration_min' has to be numeric.")
    }
    iteration_max <- ceiling(iteration_max)

    if (iteration_min > iteration_max) {
        stop("'iteration_max' has be larger than 'iteration_min'.")
    }

    if (!is.logical(save_trace)) {
        stop("'save_trace' has to be logical.")
    }

    res <- list(
        trace = trace,
        tolerance = tolerance,
        iteration_max = iteration_max, iteration_min = iteration_min,
        save_trace = save_trace
    )

    return(res)
}

#' @title itnb parameter optimisation
#'
#' @description Parameter optimisation for data generated by a r.v. following an itnb distribution using the ENM algorithm.
#'
#' @param x Numeric: Observed counts.
#' @param i Numeric: The inflation point.
#' @param t Numeric (< i): The truncation point.
#' @param control List: A control object, see \link{em_itnb_control} for details.
#'
#' @return An object of class \link{itnb-object}.
#'
#' @export
em_itnb <- function(x, i, t, control = list()) {
    UseMethod("em_itnb")
}

#' @rdname em_itnb
#' @method em_itnb numeric
#'
#' @example inst/examples/em_itnb_example.R
#'
#' @export
em_itnb.numeric <- function(x, i, t, control = list()) {
    ##
    control <- do.call(em_itnb_control, control)

    ##
    if (!is.numeric(i)) {
        stop("'i' has to be numeric.")
    }
    else if (!((length(i) == n) || length(i) == 1)) {
        stop("'i' needs to have length 1, or be equal to 'n'.")
    }
    i <- ceiling(i)

    ##
    if (is.null(t)) {
        t <- -1
    }

    if (!is.numeric(t)) {
        stop("'t' has to be numeric.")
    }
    else if (!((length(t) == n) || length(t) == 1)) {
        stop("'t' needs to have length 1, or be equal to 'n'.")
    }

    if (is.numeric(t)) {
        t <- ceiling(t)
        if (any(t >= i)) {
            stop("'t' has to be smaller than 'i'.")
        }
    }

    ##
    x_i <- as.numeric(x == i)

    ##
    p <- mean(x_i)
    mu <- mean(x[x_i == 0])

    var_x <- var(x[x_i == 0])
    theta <- ifelse(var_x > mu, 0.5 * mu^2 / (var_x - mu), 100)

    res <- em_itnb_cpp(
        x = x, xi = x_i,
        mu_0 = mu, theta_0 = theta, p_0 = p,
        i = i, t = t,
        iteration_min = control$iteration_min, iteration_max = control$iteration_max,
        tolerance = control$tolerance, # tolerance_int = control$tolerance_int, use_fd = control$use_fd,
        trace = control$trace, save_trace = control$save_trace
    )

    if (control$save_trace) {
        res$trace <- do.call("rbind", res$trace) |> t() |> as.data.frame()
        res$trace <- cbind(Iteration = seq_len(nrow(res$trace)) - 1, res$trace)
    }

    class(res) <- "itnb"
    return(res)
}

#' Confidence envelopes of itnb-object.
#'
#' @description Simulated confidence envelopes of the parameters estimated by the \link{em_itnb} function.
#'
#' @param object An \link{itnb-object}.
#' @param level Numeric: The confidence level. If left as \code{NULL} all parametric bootstrap simulations are returned.
#' @param trace TRUE/FALSE: should a trace be shown?
#' @param nr_simulations Numeric: The number of simulations used to create the confidence envelopes.
#' @param parametric TRUE/FALSE: should the envelopes be simulated using the parametric bootstrap?
#' @param plot TRUE/FALSE: should a density plot of the parameters be returned?
#'
#' @return If \code{level = NULL} a matrix with bootstrap simulations, otherwise a matrix of lower and upper confidence limits for each parameter.
#'
#' @export
simulate_ci <- function(object, level = 0.95, trace = TRUE, nr_simulations = 2000, parametric = FALSE, plot = FALSE) {
    UseMethod("simulate_ci")
}

#' @rdname simulate_ci
#' @method simulate_ci itnb
#'
#' @example inst/examples/simulation_itnb_example.R
#'
#' @export
simulate_ci.itnb <- function(object, level = 0.95, trace = TRUE, nr_simulations = 2000, parametric = FALSE, plot = FALSE) {
    ##
    n <- object$n
    x <- object$x
    i <- object$i
    t <- object$t

    ##
    mu <- object$mu
    theta <- object$theta
    p <- object$p

    ##
    mu_e <- rep(NA, nr_simulations)
    theta_e <- rep(NA, nr_simulations)
    p_e <- rep(NA, nr_simulations)

    if (trace) {
        pb <- progress_bar$new(
            format = paste0(ifelse(parametric, "Parametric", "Non-parametric"), " bootstrap (samples = ", nr_simulations, ")", ": [:bar] :percent Eta: :eta"),
            total = nr_simulations,
            clear = FALSE,
            width = 120
        )
    }

    for (j in seq_len(nr_simulations)) {
        if (trace)
            pb$tick()

        if (parametric) {
            x_j <- ritnb(n = n, mu = mu, theta = theta, p = p, i = i, t = t)
        }
        else {
            x_j <- x[sample(n, n, replace = TRUE)]
        }

        pars_j <- em_itnb(x = x_j, i = i, t = t)

        mu_e[j] <- pars_j$mu
        theta_e[j] <- pars_j$theta
        p_e[j] <- pars_j$p
    }

    if (is.null(level)) {
        complete_data_frame <- cbind(mu_e, theta_e, p_e)
        colnames(complete_data_frame) <- c("mu", "theta", "p")

        res_data_frame <- complete_data_frame
    }
    else {
        alpha <- (1 - level) / 2

        quantiles_mu <- quantile(mu_e, probs = c(alpha, 1 - alpha))
        quantiles_theta <- quantile(theta_e, probs = c(alpha, 1 - alpha))
        quantiles_p <- quantile(p_e, probs = c(alpha, 1 - alpha))

        confint_data_frame <- rbind(quantiles_mu, quantiles_theta, quantiles_p)
        rownames(confint_data_frame) <- c("mu", "theta", "p")

        res_data_frame <- confint_data_frame
    }

    if (plot) {
        par(mfrow = c(3, 1))
        hist(mu_e, breaks = "fd", xlab = bquote(mu), ylab = "Density", probability = TRUE, main = paste(ifelse(parametric, "Parametric", "Non-parametric"), "bootstrap samples"), cex.lab = 1.5, cex.main = 1.5);
        if (!is.null(level)) abline(v = quantiles_mu[1], col = "dodgerblue2", lwd = 2); abline(v = quantiles_mu[2], col = "dodgerblue2", lwd = 2)

        hist(theta_e, breaks = "fd", xlab = bquote(theta), ylab = "Density", probability = TRUE, main = paste(ifelse(parametric, "Parametric", "Non-parametric"), "bootstrap samples"), cex.lab = 1.5, cex.main = 1.5)
        if (!is.null(level)) abline(v = quantiles_theta[1], col = "dodgerblue2", lwd = 2); abline(v = quantiles_theta[2], col = "dodgerblue2", lwd = 2)

        hist(p_e, breaks = "fd", xlab = bquote(pi), ylab = "Density", probability = TRUE, main = paste(ifelse(parametric, "Parametric", "Non-parametric"), "bootstrap samples"), cex.lab = 1.5, cex.main = 1.5)
        if (!is.null(level)) abline(v = quantiles_p[1], col = "dodgerblue2", lwd = 2); abline(v = quantiles_p[2], col = "dodgerblue2", lwd = 2)

        par(mfrow = c(1, 1))
    }

    return(res_data_frame)
}

#' Plot parameter trace of an \link{itnb-object}
#'
#' @description A function plotting the EM parameter trace returned by the \link{em_itnb} function. Note: the function can only be used if the argument \code{save_trace} in the \link{em_itnb_control} function was set to \code{TRUE}.
#'
#' @param x An \link{itnb-object}.
#' @param ... Additional arguments passed to the \link[graphics]{plot} function.
#'
#' @export
plot.itnb <- function(x, ...) {
    if (is.null(x$trace))
        stop("The 'trace' tibble was not found. Set 'save_trace = TRUE' in the 'em_itnb_control' function, and re-run the optimisation routine.")

    itnb_trace <- x$trace[-1,]

    par(mfrow = c(2, 2))
    plot(itnb_trace$Iteration, itnb_trace$LogLikelihood, type = "l", xlab = "Iteration", ylab = "Log-likelihood", ...)

    plot(itnb_trace$Iteration, itnb_trace$mu, type = "l", xlab = "Iteration", ylab = bquote(mu), ...)

    plot(itnb_trace$Iteration, itnb_trace$theta, type = "l", xlab = "Iteration", ylab = bquote(theta), ...)

    plot(itnb_trace$Iteration, itnb_trace$p, type = "l", xlab = "Iteration", ylab = bquote(pi), ...)
    par(mfrow = c(1, 1))

    return(invisible(NULL))
}
