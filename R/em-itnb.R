#' Control function for the \link{em_itnb} function.
#'
#' @description Creates a list of default options.
#'
#' @param trace Numeric (>= 0): showing a trace every \code{trace} number of iterations.
#' @param tolerance Numeric (> 0): Convergence tolerance.
#' @param iteration_min Numeric (>= 0): The minimum number of allowed iterations.
#' @param iteration_max Numeric (>= \code{iteration_min}): The maximum number of allowed iterations.
#' @param steps Numeric (>= 0): The number of steps to use when approximating the integral needed for the derivative of the overdispersion.
#' @param fd TRUE/FALSE: should parameter optimisation use finite difference for the gradient?
#' @param steps_fd: Numeric (> 0): The step-size used to approximate the gradient with finite difference.
#' @param save_data TRUE/FALSE: should the data be stored in the return object?
#' @param save_trace TRUE/FALSE: should the entire trace be stored in the return object?
#'
#' @return A list of default arguments for the \link{em_itnb} function.
#' @export
em_itnb_control <- function(trace = 0, tolerance = 1e-6, iteration_min = 5, iteration_max = 10000, steps = 100, fd = TRUE, steps_fd = .Machine$double.eps^(1/3), save_data = TRUE, save_trace = FALSE) {
    ##
    if (!is.numeric(trace)) {
        stop("'trace' has to be numeric.")
    }
    trace <- ceiling(trace)

    ##
    if (!is.numeric(tolerance)) {
        stop("'tolerance' has to be numeric.")
    }

    if (tolerance < .Machine$double.eps) {
        stop("'tolerance' has to be bigger than two times the machine epsilon.")
    }

    ##
    if (!is.numeric(iteration_min)) {
        stop("'iteration_min' has to be numeric.")
    }
    iteration_min <- ceiling(iteration_min)

    if (!is.numeric(iteration_max)) {
        stop("'iteration_min' has to be numeric.")
    }
    iteration_max <- ceiling(iteration_max)

    if (iteration_min > iteration_max) {
        stop("'iteration_max' has be larger than 'iteration_min'.")
    }

    ##
    if (!is.numeric(steps)) {
        stop("'steps' has to be numeric.")
    }
    steps <- ceiling(steps)

    ##
    if (!is.logical(fd)) {
        stop("'fd' has to be logical.")
    }

    ##
    if (steps_fd < .Machine$double.eps) {
        stop("'steps_fd' has to be bigger than two times the machine epsilon.")
    }

    ##
    if (!is.logical(save_trace)) {
        stop("'save_trace' has to be logical.")
    }

    ##
    if (!is.logical(save_data)) {
        stop("'save_data' has to be logical.")
    }

    ##
    res <- list(
        trace = trace,
        tolerance = tolerance,
        iteration_max = iteration_max, iteration_min = iteration_min,
        steps = steps, fd = fd, steps_fd = steps_fd,
        save_data = save_data, save_trace = save_trace
    )

    ##
    return(res)
}


#' @title itnb parameter optimisation
#'
#' @description Parameter optimisation for data generated by a r.v. following an itnb distribution using the ENM algorithm.
#'
#' @param x Numeric: Observed counts.
#' @param i Numeric: The inflation point.
#' @param t Numeric (< i): The truncation point.
#' @param control List: A control object, see \link{em_itnb_control} for details.
#'
#' @return An object of class \link{itnb-object}.
#'
#' @export
em_itnb <- function(x, i, t, control = list()) {
    UseMethod("em_itnb")
}


#' @rdname em_itnb
#' @method em_itnb numeric
#'
#' @example inst/examples/em_itnb_example.R
#'
#' @export
em_itnb.numeric <- function(x, i, t, control = list()) {
    ##
    control <- do.call(em_itnb_control, control)

    ##
    if (!is.numeric(i)) {
        stop("'i' has to be numeric.")
    }
    else if (!((length(i) == n) || length(i) == 1)) {
        stop("'i' needs to have length 1, or be equal to 'n'.")
    }
    i <- ceiling(i)

    ##
    if (is.null(t)) {
        t <- -1
    }

    if (!is.numeric(t)) {
        stop("'t' has to be numeric.")
    }
    else if (!((length(t) == n) || length(t) == 1)) {
        stop("'t' needs to have length 1, or be equal to 'n'.")
    }

    if (is.numeric(t)) {
        t <- ceiling(t)
        if (any(t >= i)) {
            stop("'t' has to be smaller than 'i'.")
        }
    }

    ##
    x_i <- as.numeric(x == i)

    ##
    p <- mean(x_i)
    mu <- mean(x[x_i == 0])

    var_x <- var(x[x_i == 0])
    theta <- ifelse(var_x > mu, 0.5 * mu^2 / (var_x - mu), 100)

    res <- em_itnb_cpp(
        x = x, xi = x_i,
        mu_0 = mu, theta_0 = theta, p_0 = p,
        i = i, t = t,
        iteration_min = control$iteration_min, iteration_max = control$iteration_max,
        tolerance = control$tolerance, steps = control$steps,
        fd = control$fd, steps_fd = control$steps_fd,
        trace = control$trace, save_trace = control$save_trace
    )

    if (control$save_trace) {
        res[["trace"]] <- do.call("rbind", res[["trace"]]) |> t() |> as.data.frame()
        res[["trace"]] <- cbind(Iteration = seq_len(nrow(res[["trace"]])) - 1, res[["trace"]])
    }

    if (control$save_data) {
        res[["data"]] <- x
    }
    else {
        res[["data"]] <- NA
    }

    class(res) <- "itnb"
    return(res)
}


#' Extract model coefficients
#'
#' @description A function which extracts model coefficients from objects of class \code{itnb}.
#'
#' @param object An \link{itnb-object}.
#' @param ... Additional arguments (see details).
#'
#' @details The only additional argument used by the function is \code{par} used to specify which parameter should be returned by the function, i.e. it takes the values \code{"mu"}, \code{"theta"}, or \code{"p"}.
#'
#' @return If \code{par} is left as \code{NULL} a list of all parameters will be returned, otherwise the function returns the parameter specified by \code{par}.
#' @export
coef.itnb <- function(object, ...) {
    dots <- list(...)

    if (is.null(dots[["par"]])) {
        r <- object[c("mu", "theta", "p")]
    }
    else if (dots[["par"]] == "mu") {
        r <- object[["mu"]]
    }
    else if (dots[["par"]] == "theta") {
        r <- object[["theta"]]
    }
    else if (dots[["par"]] == "p") {
        r <- object[["p"]]
    }
    else {
        stop("'pars' only takes the values 'mu', 'theta', or 'p'.")
    }

    return(r)
}


#' Plot parameter trace of an \link{itnb-object}
#'
#' @description A function plotting the EM parameter trace returned by the \link{em_itnb} function. Note: the function can only be used if the argument \code{save_trace} in the \link{em_itnb_control} function was set to \code{TRUE}.
#'
#' @param x An \link{itnb-object}.
#' @param ... Additional arguments passed to the \link[graphics]{plot} function.
#'
#' @export
plot.itnb <- function(x, ...) {
    dots <- list(...)
    if (is.null(x$trace))
        stop("The 'trace' data.frame was not found. Set 'save_trace = TRUE' in the 'em_itnb_control' function, and re-run the optimisation routine.")

    itnb_trace <- x$trace
    if (!is.null(dots[["log"]])) {
        itnb_trace <- itnb_trace[-1, ]
    }

    par(mfrow = c(2, 2))
    plot(itnb_trace$Iteration, itnb_trace$LogLikelihood, type = "l", xlab = "Iteration", ylab = "Log-likelihood", ...)

    plot(itnb_trace$Iteration, itnb_trace$mu, type = "l", xlab = "Iteration", ylab = bquote(mu), ...)

    plot(itnb_trace$Iteration, itnb_trace$theta, type = "l", xlab = "Iteration", ylab = bquote(theta), ...)

    plot(itnb_trace$Iteration, itnb_trace$p, type = "l", xlab = "Iteration", ylab = bquote(pi), ...)
    par(mfrow = c(1, 1))

    return(invisible(NULL))
}
