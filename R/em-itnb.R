#' Control function for the \link{em_itnb} function.
#'
#' @description Creates a list of default options.
#'
#' @param trace Numeric (>= 0): showing a trace every \code{trace} number of iterations.
#' @param tolerance Numeric: Convergence tolerance.
#' @param iteration_min Numeric (>= 0): The minimum number of allowed iterations.
#' @param iteration_max Numeric (>= \code{iteration_min}): The maximum number of allowed iterations.
#' @param save_trace TRUE/FALSE: should the entire trace be stored?
#'
#' @return A list of default arguments for the \link{em_itnb} function.
#' @export
em_itnb_control <- function(trace = 0, tolerance = 1e-6, iteration_min = 5, iteration_max = 10000, save_trace = FALSE) {
    if (!is.numeric(trace)) {
        stop("'trace' has to be numeric.")
    }
    trace <- ceiling(trace)

    if (!is.numeric(tolerance)) {
        stop("'tolerance' has to be numeric.")
    }

    if (tolerance <= .Machine$double.eps) {
        stop("'tolerance' has to be bigger than two times the machine epsilon.")
    }

    if (!is.numeric(iteration_min)) {
        stop("'iteration_min' has to be numeric.")
    }
    iteration_min <- ceiling(iteration_min)

    if (!is.numeric(iteration_max)) {
        stop("'iteration_min' has to be numeric.")
    }
    iteration_max <- ceiling(iteration_max)

    if (iteration_min > iteration_max) {
        stop("'iteration_max' has be larger than 'iteration_min'.")
    }

    if (!is.logical(save_trace)) {
        stop("'save_trace' has to be logical.")
    }

    res <- list(
        trace = trace,
        tolerance = tolerance,
        iteration_max = iteration_max, iteration_min = iteration_min,
        save_trace = save_trace
    )

    return(res)
}

#' @title itnb parameter optimisation
#'
#' @description Parameter optimisation for data generated by a r.v. following an itnb distribution using the ENM algorithm.
#'
#' @param x Numeric: Observed counts.
#' @param i Numeric: The inflation point.
#' @param t Numeric (< i): The truncation point.
#' @param control List: A control object, see \link{em_itnb_control} for details.
#'
#' @return An object of class \link{itnb-object}.
#'
#' @export
em_itnb <- function(x, i, t, control = list()) {
    UseMethod("em_itnb")
}

#' @rdname em_itnb
#' @method em_itnb numeric
#'
#' @example inst/examples/em_itnb_example.R
#'
#' @export
em_itnb.numeric <- function(x, i, t, control = list()) {
    ##
    control <- do.call(em_itnb_control, control)

    ##
    if (!is.numeric(i)) {
        stop("'i' has to be numeric.")
    }
    else if (!((length(i) == n) || length(i) == 1)) {
        stop("'i' needs to have length 1, or be equal to 'n'.")
    }
    i <- ceiling(i)

    ##
    if (is.null(t)) {
        t <- -1
    }

    if (!is.numeric(t)) {
        stop("'t' has to be numeric.")
    }
    else if (!((length(t) == n) || length(t) == 1)) {
        stop("'t' needs to have length 1, or be equal to 'n'.")
    }

    if (is.numeric(t)) {
        t <- ceiling(t)
        if (any(t >= i)) {
            stop("'t' has to be smaller than 'i'.")
        }
    }

    ##
    x_i <- as.numeric(x == i)

    ##
    p <- mean(x_i)
    mu <- mean(x[x_i == 0])

    var_x <- var(x[x_i == 0])
    theta <- ifelse(var_x > mu, 0.5 * mu^2 / (var_x - mu), 100)

    res <- em_itnb_cpp(
        x = x, xi = x_i,
        mu_0 = mu, theta_0 = theta, p_0 = p,
        i = i, t = t,
        iteration_min = control$iteration_min, iteration_max = control$iteration_max,
        tolerance = control$tolerance, # tolerance_int = control$tolerance_int, use_fd = control$use_fd,
        trace = control$trace, save_trace = control$save_trace
    )

    if (control$save_trace) {
        res$trace <- do.call("rbind", res$trace) |> t() |> as.data.frame()
        res$trace <- cbind(Iteration = seq_len(nrow(res$trace)) - 1, res$trace)
    }

    class(res) <- "itnb"
    return(res)
}

#' Plot parameter trace of an \link{itnb-object}
#'
#' @description A function plotting the EM parameter trace returned by the \link{em_itnb} function. Note: the function can only be used if the argument \code{save_trace} in the \link{em_itnb_control} function was set to \code{TRUE}.
#'
#' @param x An \link{itnb-object}.
#' @param ... Additional arguments passed to the \link[graphics]{plot} function.
#'
#' @export
plot.itnb <- function(x, ...) {
    if (is.null(x$trace))
        stop("The 'trace' tibble was not found. Set 'save_trace = TRUE' in the 'em_itnb_control' function, and re-run the optimisation routine.")

    itnb_trace <- x$trace[-1,]

    par(mfrow = c(2, 2))
    plot(itnb_trace$Iteration, itnb_trace$LogLikelihood, type = "l", xlab = "Iteration", ylab = "Log-likelihood", ...)

    plot(itnb_trace$Iteration, itnb_trace$mu, type = "l", xlab = "Iteration", ylab = bquote(mu), ...)

    plot(itnb_trace$Iteration, itnb_trace$theta, type = "l", xlab = "Iteration", ylab = bquote(theta), ...)

    plot(itnb_trace$Iteration, itnb_trace$p, type = "l", xlab = "Iteration", ylab = bquote(pi), ...)
    par(mfrow = c(1, 1))

    return(invisible(NULL))
}
